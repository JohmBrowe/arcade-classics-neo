<!DOCTYPE html><html lang="en"><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Chess vs Bot — Arcade Classics Neo</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f1c;color:#e8e8ff;font-family:system-ui}
  #root{display:grid;place-items:center;height:100%}
  #board{width:min(92vmin,560px);aspect-ratio:1;border:8px solid #151a2b;border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,.4);display:grid;grid-template:repeat(8,1fr)/repeat(8,1fr);overflow:hidden}
  .sq{display:grid;place-items:center;font-size:calc(min(9vmin,56px));user-select:none;cursor:pointer}
  .d{background:#2a3358}.l{background:#c7d2ff22}
  .sel{outline:3px solid #66ccff}
  .hint{box-shadow: inset 0 0 0 3px #ffd44d66}
  #bar{position:fixed;inset:auto 0 0 0;display:flex;gap:8px;justify-content:center;padding:10px;background:linear-gradient(0,#0b0f1c,transparent)}
  button,select{background:#101425;color:#e8e8ff;border:1px solid #2a3358;border-radius:10px;padding:10px 14px;font-size:16px}
  #status{margin:8px 0 0;text-align:center;color:#aab3d9}
</style></head><body>
<div id="root">
  <div id="board"></div>
  <div id="status">Your turn: White</div>
</div>
<div id="bar">
  <button onclick="newGame()">New</button>
  <button onclick="undo()">Undo</button>
  <label>Bot:
    <select id="lvl" onchange="lvl=parseInt(this.value)">
      <option value="1">Easy</option>
      <option value="2" selected>Normal</option>
      <option value="3">Hard</option>
    </select>
  </label>
</div>
<script>
const PIECE = {p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚',P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔'};
const VALUE = {p:1,n:3,b:3,r:5,q:9,k:100};

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');

let S, side, hist=[], sel=null, hints=[], lvl=2;

function startPosition(){
  return [
   'rnbqkbnr',
   'pppppppp',
   '........',
   '........',
   '........',
   '........',
   'PPPPPPPP',
   'RNBQKBNR'
  ].map(r=>r.split(''));
}
function color(c){ return c===c.toUpperCase()? 1 : -1 } // 1 white, -1 black
function inside(x,y){ return x>=0 && x<8 && y>=0 && y<8 }
function pieceAt(x,y){ return S[y][x] }
function setPiece(x,y,v){ S[y][x]=v }

function draw(){
  boardEl.innerHTML='';
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const d=document.createElement('div');
    d.className='sq '+(((x+y)&1)?'d':'l');
    const p=pieceAt(x,y);
    if(p!=='.') d.textContent = PIECE[p];
    d.dataset.x=x; d.dataset.y=y;
    boardEl.appendChild(d);
  }
  if(sel){ cell(sel.x,sel.y).classList.add('sel'); for(const [, ,tx,ty] of hints) cell(tx,ty).classList.add('hint'); }
}
const cell=(x,y)=>boardEl.children[y*8+x];

// ---------- MOVE GENERATION ----------
function pseudoMovesFor(x,y){
  const p=pieceAt(x,y); if(p==='.') return [];
  const c=color(p), t=p.toLowerCase(); const mv=[];
  const push=(nx,ny)=>{ if(!inside(nx,ny))return; const q=pieceAt(nx,ny); if(q==='.' || color(q)!==c) mv.push([x,y,nx,ny]); };

  if(t==='p'){ // pawns
    const dy=c===1?-1:1, sy=c===1?6:1;
    if(pieceAt(x,y+dy)==='.') mv.push([x,y,x,y+dy]);
    if(y===sy && pieceAt(x,y+dy)==='.' && pieceAt(x,y+2*dy)==='.') mv.push([x,y,x,y+2*dy]);
    for(const dx of [-1,1]){
      const nx=x+dx, ny=y+dy;
      if(inside(nx,ny) && pieceAt(nx,ny)!=='.' && color(pieceAt(nx,ny))!==c) mv.push([x,y,nx,ny]);
    }
  }
  if(t==='n'){ for(const [dx,dy] of [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]]) push(x+dx,y+dy); }
  if(t==='b' || t==='r' || t==='q'){
    const dirs=[]; if(t!=='r') dirs.push([1,1],[-1,1],[1,-1],[-1,-1]);
    if(t!=='b')  dirs.push([1,0],[-1,0],[0,1],[0,-1]);
    for(const [dx,dy] of dirs){
      let nx=x+dx, ny=y+dy;
      while(inside(nx,ny)){
        const q=pieceAt(nx,ny);
        if(q==='.'){ mv.push([x,y,nx,ny]); } else { if(color(q)!==color(p)) mv.push([x,y,nx,ny]); break; }
        nx+=dx; ny+=dy;
      }
    }
  }
  if(t==='k'){ for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++) if(dx||dy) push(x+dx,y+dy); }
  return mv;
}

function findKing(c){
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p=pieceAt(x,y); if(p!=='.' && color(p)===c && p.toLowerCase()==='k') return {x,y};
  }
  return null;
}

function inCheck(c){
  const k=findKing(c); if(!k) return true;
  const enemy=-c;
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const p=pieceAt(x,y);
    if(p!=='.' && color(p)===enemy){
      const moves=pseudoMovesFor(x,y);
      if(moves.some(m=>m[2]===k.x && m[3]===k.y)) return true;
    }
  }
  return false;
}

function legalMovesFor(x,y){
  const c=color(pieceAt(x,y));
  const res=[];
  for(const m of pseudoMovesFor(x,y)){
    const cap=apply(m,false);
    const chk=inCheck(c);
    undoOne(m,cap,false);
    if(!chk) res.push(m);
  }
  return res;
}

// ---------- MAKE / UNDO ----------
function apply(m,flip=true){
  const [x,y,nx,ny]=m; const p=pieceAt(x,y); const cap=pieceAt(nx,ny);
  setPiece(nx,ny,p); setPiece(x,y,'.');
  // simple promotion
  if(p==='P' && ny===0) setPiece(nx,ny,'Q');
  if(p==='p' && ny===7) setPiece(nx,ny,'q');
  if(flip) side*=-1;
  return cap;
}
function undoOne(m,cap,flip=true){
  const [x,y,nx,ny]=m; const p=pieceAt(nx,ny);
  setPiece(x,y,p); setPiece(nx,ny,cap);
  if(flip) side*=-1;
}

// ---------- BOT ----------
function allLegalMoves(c){
  const out=[];
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const p=pieceAt(x,y);
    if(p!=='.' && color(p)===c){
      for(const m of legalMovesFor(x,y)) out.push(m);
    }
  }
  return out;
}
function evalBoard(){
  let v=0;
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const p=pieceAt(x,y);
    if(p!=='.') v += (VALUE[p.toLowerCase()]||0) * color(p);
  }
  return v;
}
function search(depth,turn){
  if(depth===0) return {score: evalBoard()*turn};
  let best=-1e9, bestM=null;
  const moves=allLegalMoves(turn);
  for(const m of moves){
    const cap=apply(m);
    const r=search(depth-1,-turn);
    undoOne(m,cap);
    const s=-r.score;
    if(s>best){best=s; bestM=m;}
  }
  return {score:best, move:bestM};
}

// ---------- UI ----------
boardEl.addEventListener('click', (e)=>{
  const t=e.target.closest('.sq'); if(!t) return;
  const x=+t.dataset.x, y=+t.dataset.y;
  if(sel){
    // try to move
    const mv = hints.find(([, ,tx,ty])=>tx===x&&ty===y);
    if(mv){ move(mv); sel=null; hints=[]; draw(); setTimeout(botTurn,150); return; }
    // otherwise reselect
    sel=null; hints=[];
  }
  const p=pieceAt(x,y);
  if(p!=='.' && color(p)===side){
    sel={x,y};
    hints=legalMovesFor(x,y);
  }
  draw();
});

function move(m){
  const cap=apply(m);
  hist.push({m,cap});
  statusEl.textContent='Bot thinking…';
}
function undo(){
  const h=hist.pop(); if(!h) return;
  undoOne(h.m,h.cap);
  sel=null; hints=[];
  statusEl.textContent = side===1?'Your turn: White':'Your turn: Black';
  draw();
}
function newGame(){
  S=startPosition(); side=1; hist=[]; sel=null; hints=[];
  statusEl.textContent='Your turn: White';
  draw();
}
function botTurn(){
  if(side===-1){
    const {move}=search(lvl,-1);
    if(move){ const cap=apply(move); hist.push({m:move,cap}); }
    statusEl.textContent='Your turn: White';
    draw();
  }
}

// init
newGame();
</script></body></html>
